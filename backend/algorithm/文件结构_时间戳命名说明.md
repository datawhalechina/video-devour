# 文件结构 - 时间戳命名说明

## 📋 概述

项目中所有输出文件和目录都采用统一的时间戳命名方案，确保每次运行的结果都可追溯、不会相互覆盖。

## 🕐 时间戳格式

**统一格式**：`YYYYMMDD_HHMMSS`

- **示例**：`20251006_103000`（2025年10月6日 10:30:00）
- **特点**：
  - 易于阅读
  - 文件系统友好（无特殊字符）
  - 可排序（字母顺序即时间顺序）
  - 唯一性（精确到秒）

## 📁 完整文件结构

### 单次运行的输出结构

假设时间戳为 `20251006_103000`：

```
output/
├── outline_20251006_103000.md                          # 初始大纲
├── detailed_outline_20251006_103000.md                 # 详细大纲（含匹配文本）
│
├── videocut_20251006_103000/                           # 视频切片目录
│   ├── 01_项目架构图.mp4
│   ├── 02_微调模块与Prompt优化模块.mp4
│   ├── 03_知识库问答流程.mp4
│   └── ...
│
├── frames_01_项目架构图_20251006_103000/              # 帧提取目录（视频1）
│   ├── frame_0001.jpg
│   ├── frame_0002.jpg
│   └── ...
│
├── frames_02_微调模块与Prompt优化模块_20251006_103000/ # 帧提取目录（视频2）
│   ├── frame_0001.jpg
│   ├── frame_0002.jpg
│   └── ...
│
└── frames_03_知识库问答流程_20251006_103000/          # 帧提取目录（视频3）
    ├── frame_0001.jpg
    ├── frame_0002.jpg
    └── ...
```

## 📊 文件命名规则

### 1. 大纲文件

| 文件类型 | 命名格式 | 示例 |
|---------|---------|------|
| 初始大纲 | `outline_时间戳.md` | `outline_20251006_103000.md` |
| 详细大纲 | `detailed_outline_时间戳.md` | `detailed_outline_20251006_103000.md` |

**特点**：
- ✅ 大纲文件位于 `output/` 根目录
- ✅ 同一次运行的两个大纲文件共享相同的时间戳
- ✅ 便于追踪大纲的生成时间

### 2. 视频切片目录

| 类型 | 命名格式 | 示例 |
|------|---------|------|
| 目录 | `videocut_时间戳/` | `videocut_20251006_103000/` |
| 视频文件 | `序号_标题.mp4` | `01_项目架构图.mp4` |

**特点**：
- ✅ 所有视频切片保存在带时间戳的母文件夹下
- ✅ 视频文件名包含序号和标题
- ✅ 标题中的特殊字符已被清理

### 3. 帧提取目录

| 类型 | 命名格式 | 示例 |
|------|---------|------|
| 目录 | `frames_视频名_时间戳/` | `frames_01_项目架构图_20251006_103000/` |
| 图片文件 | `frame_序号.jpg` | `frame_0001.jpg` |

**特点**：
- ✅ 每个视频的帧文件独立存储
- ✅ 目录名包含原视频名和时间戳
- ✅ 帧文件采用4位数字编号（0001-9999）

## 🔄 时间戳的传递和一致性

### 工作流程

```
1. main.py 生成时间戳
   ↓
2. save_outline() 使用时间戳保存大纲
   ↓ (返回 outline_path)
3. 从 outline_path 提取时间戳
   ↓
4. generate_detailed_outline() 使用相同时间戳
   ↓
5. cut_videos_by_headings() 使用相同时间戳
   ↓ (返回 videocut_path)
6. extract_frames_from_videos() 使用相同时间戳
```

### 代码实现

```python
# main.py 中的实现
def main():
    # 保存大纲并获取路径
    outline_path = outline_handler.save_outline(outline)
    
    # 从路径中提取时间戳（保持一致性）
    outline_timestamp = os.path.basename(outline_path).replace('outline_', '').replace('.md', '')
    
    # 后续步骤都使用相同的时间戳
    outline_handler.generate_detailed_outline(..., timestamp=outline_timestamp)
    videocut_path = video_handler.cut_videos_by_headings(..., timestamp=outline_timestamp)
    video_handler.extract_frames_from_videos(..., timestamp=outline_timestamp)
```

## 🎯 设计优势

### 1. **可追溯性**
- ✅ 每次运行都有唯一的时间标识
- ✅ 可以轻松找到某个时间点的所有输出
- ✅ 便于问题排查和结果对比

### 2. **避免覆盖**
- ✅ 多次运行不会相互覆盖
- ✅ 可以保留历史运行记录
- ✅ 便于对比不同参数的效果

### 3. **文件关联**
- ✅ 相同时间戳的文件属于同一次运行
- ✅ 便于批量管理和清理
- ✅ 文件名自包含完整信息

### 4. **易于查找**
- ✅ 按时间戳排序即按运行时间排序
- ✅ 最新的结果总是在最后
- ✅ 支持通配符快速查找

## 💡 使用示例

### 查找最新的大纲文件

```bash
# Windows PowerShell
Get-ChildItem output\outline_*.md | Sort-Object Name -Descending | Select-Object -First 1

# Linux/Mac
ls -t output/outline_*.md | head -1
```

### Python 脚本查找最新结果

```python
import glob
from pathlib import Path

def find_latest_results(output_dir="output"):
    """查找最新一次运行的所有输出"""
    output_path = Path(output_dir)
    
    # 查找最新的大纲文件
    outline_files = sorted(output_path.glob("outline_*.md"))
    if not outline_files:
        return None
    
    latest_outline = outline_files[-1]
    
    # 从文件名提取时间戳
    timestamp = latest_outline.name.replace('outline_', '').replace('.md', '')
    
    # 构建相关文件和目录的路径
    results = {
        'timestamp': timestamp,
        'outline': str(latest_outline),
        'detailed_outline': str(output_path / f"detailed_outline_{timestamp}.md"),
        'videocut_dir': str(output_path / f"videocut_{timestamp}"),
        'frames_dirs': list(output_path.glob(f"frames_*_{timestamp}"))
    }
    
    return results

# 使用示例
latest = find_latest_results()
if latest:
    print(f"最新运行时间戳: {latest['timestamp']}")
    print(f"大纲文件: {latest['outline']}")
    print(f"视频切片目录: {latest['videocut_dir']}")
    print(f"帧目录数量: {len(latest['frames_dirs'])}")
```

### 清理旧文件

```python
from pathlib import Path
from datetime import datetime, timedelta
import shutil

def cleanup_old_results(days=7, output_dir="output"):
    """
    删除超过指定天数的输出文件
    
    Args:
        days: 保留最近多少天的数据
        output_dir: 输出目录路径
    """
    output_path = Path(output_dir)
    cutoff_date = datetime.now() - timedelta(days=days)
    
    # 清理大纲文件
    for outline_file in output_path.glob("outline_*.md"):
        timestamp_str = outline_file.name.replace('outline_', '').replace('.md', '')
        try:
            file_date = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
            if file_date < cutoff_date:
                print(f"删除旧大纲: {outline_file}")
                outline_file.unlink()
        except ValueError:
            pass
    
    # 清理详细大纲文件
    for outline_file in output_path.glob("detailed_outline_*.md"):
        timestamp_str = outline_file.name.replace('detailed_outline_', '').replace('.md', '')
        try:
            file_date = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
            if file_date < cutoff_date:
                print(f"删除旧详细大纲: {outline_file}")
                outline_file.unlink()
        except ValueError:
            pass
    
    # 清理视频切片目录
    for videocut_dir in output_path.glob("videocut_*"):
        if videocut_dir.is_dir():
            timestamp_str = videocut_dir.name.replace('videocut_', '')
            try:
                dir_date = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
                if dir_date < cutoff_date:
                    print(f"删除旧视频目录: {videocut_dir}")
                    shutil.rmtree(videocut_dir)
            except ValueError:
                pass
    
    # 清理帧目录
    for frames_dir in output_path.glob("frames_*"):
        if frames_dir.is_dir():
            # 从目录名提取时间戳（最后一个下划线后的部分）
            parts = frames_dir.name.split('_')
            if len(parts) >= 2:
                timestamp_str = f"{parts[-2]}_{parts[-1]}"
                try:
                    dir_date = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
                    if dir_date < cutoff_date:
                        print(f"删除旧帧目录: {frames_dir}")
                        shutil.rmtree(frames_dir)
                except ValueError:
                    pass

# 使用示例
cleanup_old_results(days=7)  # 只保留最近7天的数据
```

## 📝 日志输出示例

运行 `main.py` 时的日志输出：

```
============================================================
开始处理流程 - 时间戳: 20251006_103000
============================================================
--- 步骤 1: 开始处理ASR数据 ---
检测到新格式（Paraformer V2），共 89 个句子
--- ASR数据处理完成 ---

--- 步骤 2: 开始生成LLM大纲 ---
--- LLM大纲生成完成 ---

--- 步骤 3: 正在将大纲保存到 output/outline_20251006_103000.md ---
--- 大纲保存成功 ---

--- 步骤 4: 正在将文本块与大纲标题进行匹配 ---
...

--- 步骤 5: 正在生成详细大纲文件到 output/detailed_outline_20251006_103000.md ---
--- 详细大纲生成成功 ---

--- 步骤 6: 开始根据大纲切分视频 ---
视频片段将保存到: output/videocut_20251006_103000
--- 视频切分完成，共生成 3 个视频片段 ---

--- 步骤 7: 开始从视频片段中提取帧 ---
从目录读取视频文件: output/videocut_20251006_103000
找到 3 个视频文件
正在从 '01_项目架构图.mp4' 提取帧到 'output/frames_01_项目架构图_20251006_103000'...
成功从 '01_项目架构图.mp4' 提取了 120 帧。
--- 帧提取完成，总共提取了 350 帧 ---

============================================================
处理流程完成 - 时间戳: 20251006_103000
============================================================
```

## 🔧 配置文件

在 `config.py` 中的相关配置：

```python
# 这些路径仅用作参考，实际输出会添加时间戳
OUTPUT_DIR = os.path.join(PROJECT_ROOT, 'output')
OUTLINE_MD_PATH = os.path.join(OUTPUT_DIR, 'outline.md')
DETAILED_OUTLINE_MD_PATH = os.path.join(OUTPUT_DIR, 'detailed_outline.md')
VIDEO_CUT_DIR = os.path.join(OUTPUT_DIR, 'videocut')
IMAGE_OUTPUT_DIR = os.path.join(OUTPUT_DIR, 'frames')
```

**注意**：配置文件中的路径仅用于获取 `output/` 目录的位置，实际文件名会在运行时添加时间戳。

## 📚 相关文档

- [DATA_PROCESSOR_V2_说明.md](./DATA_PROCESSOR_V2_说明.md) - 数据处理器说明
- [FRAMES_结构说明.md](./FRAMES_结构说明.md) - 帧提取详细说明
- [ASR_PARAFORMER_V2_说明.md](../../ASR_PARAFORMER_V2_说明.md) - ASR 引擎说明

## 📮 技术支持

如有问题或建议，请提交 Issue。

